{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CProblems","text":"<p>A problem well stated is a problem half solved.</p> <ul> <li>Complete article on famous competitive programming problems.</li> </ul>"},{"location":"#how-to-contribute","title":"How to contribute","text":"<ul> <li>Read   <code>CONTRIBUTING.md</code>   before contributing.</li> <li>Give this project a star on github if this helped you.</li> </ul>"},{"location":"#navigation","title":"Navigation","text":"ProblemsTags <p>This page contains list of all problems, more recent one are at the top.</p> <p>View Problems</p> <p>This page contains problems grouped by tags.</p> <p>View Tags</p>"},{"location":"#license","title":"License","text":"<p>Creative Commons license CC BY-NC</p> <p></p> <p>This license lets others remix, adapt, and build upon your work non-commercially, and  although their new works must also acknowledge you and be non-commercial, they don\u2019t  have to license their derivative works on the same terms.</p>"},{"location":"problems/find-the-row-with-maximum-number-1s/","title":"Find the row with maximum 1's matrix","text":""},{"location":"problems/find-the-row-with-maximum-number-1s/#problem","title":"Problem","text":"<ul> <li>Given a boolean 2D array, where each row is sorted.</li> <li>Find the row with the maximum number of 1s.</li> </ul>"},{"location":"problems/find-the-row-with-maximum-number-1s/#input-and-output","title":"Input and Output","text":"<p>Test Case</p> Case 1 <pre><code>4 4\n0 1 1 1\n0 0 1 1\n1 1 1 1\n0 0 0 0\n</code></pre> <pre><code>2\n</code></pre>"},{"location":"problems/find-the-row-with-maximum-number-1s/#solutions","title":"Solutions","text":""},{"location":"problems/find-the-row-with-maximum-number-1s/#naive-approach","title":"Naive Approach","text":"<p>A simple method is to do a row-wise traversal of the matrix, count the number of 1s in each row, and compare the count with max. Finally, return the index of the row with maximum 1s.</p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint rowWithMax1s(vector&lt;vector&lt;int&gt;&gt; mat) {\n  int rowIndex = -1;\n  int maxCount = 0;\n  for (int i = 0; i &lt; mat.size(); i++) {\n    int count = 0;\n    for (int j = 0; j &lt; mat[i].size(); j++) {\n      if (mat[i][j] == 1) count++;\n    }\n    if (count &gt; maxCount) {\n      maxCount = count;\n      rowIndex = i;\n    }\n  }\n  return rowIndex;\n}\n\nint main() {\n  int n, m;\n  cin &gt;&gt; n &gt;&gt; m;\n  vector&lt;vector&lt;int&gt;&gt; mat(n, vector&lt;int&gt;(m, 0));\n  for (int i = 0; i &lt; n; i++) {\n    for (int j = 0; j &lt; m; j++) cin &gt;&gt; mat[i][j];\n  }\n  cout &lt;&lt; rowWithMax1s(mat);\n  return 0;\n}\n</code></pre> <ul> <li>Time Complexity: \\(O(m*n)\\)</li> <li>Space Complexity:  \\(O(1)\\)</li> <li>\\(m\\) - no of columns of matrix</li> <li>\\(n\\) - no of rows of matrix</li> </ul>"},{"location":"problems/find-the-row-with-maximum-number-1s/#binary-search","title":"Binary Search","text":"<p>We can do better. Since each row is sorted, we can use Binary Search to count of 1s in each row. We find the index of first instance of 1 in each row. The count of 1s will be equal to total number of columns minus the index of first 1.</p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint binarySearch(vector&lt;int&gt;&amp; arr, int low, int high) {\n  if (high &gt;= low) {\n    int mid = low + (high - low) / 2;\n    if ((mid == 0 || arr[mid - 1] == 0) &amp;&amp; arr[mid] == 1) return mid;\n    else if (arr[mid] == 0)\n      return binarySearch(arr, (mid + 1), high);\n    else\n      return binarySearch(arr, low, (mid - 1));\n  }\n  return -1;\n}\n\nint rowWithMax1s(vector&lt;vector&lt;int&gt;&gt;&amp; mat) {\n  int max_row_index = 0, max = -1;\n  int i, index;\n  for (i = 0; i &lt; mat.size(); i++) {\n    // do binary search\n    index = binarySearch(mat[i], 0, mat[i].size() - 1);\n    if (index != -1 &amp;&amp; mat[i].size() - index &gt; max) {\n      max = mat[i].size() - index;\n      max_row_index = i;\n    }\n  }\n  return max_row_index;\n}\n\nint main() {\n  int n, m;\n  cin &gt;&gt; n &gt;&gt; m;\n  vector&lt;vector&lt;int&gt;&gt; mat(n, vector&lt;int&gt;(m, 0));\n  for (int i = 0; i &lt; n; i++) {\n    for (int j = 0; j &lt; m; j++) cin &gt;&gt; mat[i][j];\n  }\n  cout &lt;&lt; rowWithMax1s(mat);\n  return 0;\n}\n</code></pre> <ul> <li>Time Complexity: \\(O(m \\log n)\\) where m is number of rows and n is number of columns in matrix.</li> <li>Auxiliary Space:  \\(O(\\log n)\\), as implicit stack is created due to recursion.</li> <li>\\(m\\) - no of columns of matrix</li> <li>\\(n\\) - no of rows of matrix</li> </ul>"},{"location":"problems/find-the-row-with-maximum-number-1s/#linear-search-only-on-some-rows","title":"Linear Search only on some rows","text":"<p>The above solution can be optimized further. Instead of doing binary search in every row, we first check whether the row has more 1s than max so far. If the row has more 1s, then only count 1s in the row. Also, to count 1s in a row, we don\u2019t do binary search in complete row, we do search in before the index of last max.</p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint rowWithMax1s(vector&lt;vector&lt;int&gt;&gt; mat) {\n  int j, max_row_index = 0;\n  j = mat[0].size() - 1;\n\n  for (int i = 0; i &lt; mat.size(); i++) {\n    bool flag = false; // to check whether a row has more 1's than previous\n    while (j &gt;= 0 &amp;&amp; mat[i][j] == 1) {\n      j--;\n      flag = true;\n    }\n    if (flag) max_row_index = i;\n  }\n  if (max_row_index == 0 &amp;&amp; mat[0][mat[0].size() - 1] == 0) return -1;\n  return max_row_index;\n}\n\nint main() {\n  int n, m;\n  cin &gt;&gt; n &gt;&gt; m;\n  vector&lt;vector&lt;int&gt;&gt; mat(n, vector&lt;int&gt;(m, 0));\n  for (int i = 0; i &lt; n; i++) {\n    for (int j = 0; j &lt; m; j++) cin &gt;&gt; mat[i][j];\n  }\n  cout &lt;&lt; rowWithMax1s(mat);\n  return 0;\n}\n</code></pre> <ul> <li>Time Complexity: \\(O(m+n)\\) where m is number of rows and n is number of columns in matrix.</li> <li>Auxiliary Space:  \\(O(1)\\), as implicit stack is created due to recursion.</li> <li>\\(m\\) - no of columns of matrix</li> <li>\\(n\\) - no of rows of matrix</li> </ul>"},{"location":"problems/job-sequencing-problem/","title":"Job Sequencing Problem","text":"","tags":["greedy"]},{"location":"problems/job-sequencing-problem/#problem","title":"Problem","text":"<ul> <li>Given an array of jobs where every job has a deadline and associated profit if   the job is finished before the deadline.</li> <li>It is also given that every job takes a single unit of time,   so the minimum possible deadline for any job is 1.</li> <li>Maximize the total profit if only one job can be scheduled at a time.</li> </ul>","tags":["greedy"]},{"location":"problems/job-sequencing-problem/#input-and-output","title":"Input and Output","text":"<ul> <li>Input Format<ul> <li>First line contains \\(n\\) denoting the number of jobs</li> <li>Next \\(n\\) line each contain job-id, deadline and profit of jobs.</li> </ul> </li> </ul> <p>Test Case</p> Case 1Case 2 <pre><code>4\na 4 20\nb 1 10\nc 1 40\nd 1 30\n</code></pre> <pre><code>c a\n</code></pre> <pre><code>5\na 2 100\nb 1 19\nc 2 27\nd 1 25\ne 3 15\n</code></pre> <pre><code>c a e\n</code></pre>","tags":["greedy"]},{"location":"problems/job-sequencing-problem/#solutions","title":"Solutions","text":"","tags":["greedy"]},{"location":"problems/job-sequencing-problem/#naive-approach","title":"Naive Approach","text":"<ul> <li>Generate all subsets of a given set of jobs</li> <li>and check individual subsets for the feasibility of jobs in that subset.</li> <li>Keep track of maximum profit among all feasible subsets.</li> </ul> C++ <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nstruct Job {\n  char id;\n  int dead;\n  int profit;\n};\n\nvoid printJobScheduling(vector&lt;Job&gt;&amp; arr) {\n}\n\nint main() {\n  int n;\n  cin &gt;&gt; n;\n  vector&lt;Job&gt; arr(n, {'a', 0, 0});\n  for (int i = 0; i &lt; n; i++) cin &gt;&gt; arr[i].id &gt;&gt; arr[i].dead &gt;&gt; arr[i].profit;\n  printJobScheduling(arr);\n  return 0;\n}\n</code></pre> <ul> <li>Time Complexity: \\(O(2^n)\\)</li> <li>Auxiliary Space: \\(O(n)\\)</li> <li>\\(n\\) - no of jobs</li> </ul>","tags":["greedy"]},{"location":"problems/job-sequencing-problem/#greedy-approach","title":"Greedy approach","text":"<p>Greedily choose the jobs with maximum profit first, by sorting the jobs in decreasing order of their profit. This would help to maximize the total profit as choosing the job with maximum profit for every time slot will eventually maximize the total profit</p> <p>Follow the given steps to solve the problem:</p> <ul> <li>Sort all jobs in decreasing order of profit.</li> <li>Iterate on jobs in decreasing order of profit.For each job , do the following :</li> <li>Find a time slot i, such that slot is empty and i &lt; deadline and i is greatest.   Put the job in this slot and mark this slot filled.</li> <li>If no such i exists, then ignore the job.</li> </ul> C++ <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nstruct Job {\n  char id;\n  int dead;\n  int profit;\n};\n\nvoid printJobScheduling(vector&lt;Job&gt; arr) {\n  int n = arr.size();\n  sort(arr.begin(), arr.end(), [](const Job&amp; a, const Job&amp; b) { return a.profit &gt; b.profit; });\n\n  vector&lt;int&gt; result(n);\n  vector&lt;bool&gt; slot(n, false);\n\n  for (int i = 0; i &lt; n; i++) {\n    for (int j = min(n, arr[i].dead) - 1; j &gt;= 0; j--) {\n      if (slot[j] == false) {\n        result[j] = i;\n        slot[j] = true;\n        break;\n      }\n    }\n  }\n\n  for (int i = 0; i &lt; n; i++)\n    if (slot[i])\n      cout &lt;&lt; arr[result[i]].id &lt;&lt; \" \";\n}\n\nint main() {\n  int n;\n  cin &gt;&gt; n;\n  vector&lt;Job&gt; arr(n, {'a', 0, 0});\n  for (int i = 0; i &lt; n; i++) cin &gt;&gt; arr[i].id &gt;&gt; arr[i].dead &gt;&gt; arr[i].profit;\n  printJobScheduling(arr);\n  return 0;\n}\n</code></pre> <ul> <li>Time Complexity: \\(O(n^2)\\)</li> <li>Auxiliary Space: \\(O(n)\\)</li> <li>\\(n\\) - no of jobs</li> </ul>","tags":["greedy"]},{"location":"problems/job-sequencing-problem/#priority-queue-max-heap","title":"Priority-Queue (Max-Heap)","text":"<ul> <li>Sort the jobs in the increasing order of their deadlines and</li> <li>then calculate the available slots between every two consecutive deadlines   while iterating from the end.</li> <li>Include the profit of the job at the root of the Max-Heap while the empty   slots are available and Heap is not empty, as this would help to choose the jobs   with maximum profit for every set of available slots.</li> </ul> <p>Follow the given steps to solve the problem:</p> <ul> <li>Sort the jobs based on their deadlines.</li> <li>Iterate from the end and calculate the available slots between every two   consecutive deadlines.</li> <li>Insert the profit, deadline, and job ID of ith job in the max heap.</li> <li>While the slots are available and there are jobs left in the max heap,   include the job ID with maximum profit and deadline in the result.</li> <li>Sort the result array based on their deadlines.</li> </ul> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nstruct Job {\n  char id;\n  int dead;\n  int profit;\n};\n\nvoid printJobScheduling(vector&lt;Job&gt; arr) {\n  int n = arr.size();\n  vector&lt;Job&gt; result;\n  sort(arr.begin(), arr.end(), [](Job a, Job b) { return a.dead &lt; b.dead; });\n  auto compare = [](const Job&amp; a, const Job&amp; b) { return a.profit &lt; b.profit; };\n  priority_queue&lt;Job, vector&lt;Job&gt;, decltype(compare)&gt; pq(compare);\n\n  for (int i = n - 1; i &gt;= 0; i--) {\n    int slot_available = (i == 0) ? arr[i].dead : (arr[i].dead - arr[i - 1].dead);\n    pq.push(arr[i]);\n    while (slot_available &gt; 0 &amp;&amp; pq.size() &gt; 0) {\n      result.push_back(pq.top());\n      pq.pop();\n      slot_available--;\n    }\n  }\n\n  sort(result.begin(), result.end(), [&amp;](Job a, Job b) { return a.dead &lt; b.dead; });\n  for (int i = 0; i &lt; result.size(); i++) cout &lt;&lt; result[i].id &lt;&lt; ' ';\n  cout &lt;&lt; endl;\n}\n\nint main() {\n  int n;\n  cin &gt;&gt; n;\n  vector&lt;Job&gt; arr(n, {'a', 0, 0});\n  for (int i = 0; i &lt; n; i++) cin &gt;&gt; arr[i].id &gt;&gt; arr[i].dead &gt;&gt; arr[i].profit;\n  printJobScheduling(arr);\n  return 0;\n}\n</code></pre> <ul> <li>Time Complexity: \\(O(n \\log n)\\)</li> <li>Auxiliary Space: \\(O(n)\\)</li> <li>\\(n\\) - number of jobs</li> </ul>","tags":["greedy"]},{"location":"problems/job-sequencing-problem/#references-and-external-links","title":"References and External Links","text":"<ul> <li>https://en.wikipedia.org/wiki/Job-shop_scheduling</li> <li>https://en.wikipedia.org/wiki/Interval_scheduling</li> <li>https://www.geeksforgeeks.org/job-sequencing-problem/</li> <li>https://practice.geeksforgeeks.org/problems/job-sequencing-problem/0</li> <li>https://www.techiedelight.com/job-sequencing-problem-deadlines/</li> </ul>","tags":["greedy"]},{"location":"problems/pattern-matching/","title":"Pattern Matching","text":"","tags":["string"]},{"location":"problems/pattern-matching/#problem","title":"Problem","text":"<ul> <li>given pattern and a string to search pattern for</li> <li>return all the index where pattern can be found</li> </ul>","tags":["string"]},{"location":"problems/pattern-matching/#input-and-output","title":"Input and Output","text":"<ul> <li>Input Format<ul> <li>First letter contains \\(n\\) \\(m\\) number of character in search string and pattern string</li> <li>Next tow line contains search string and pattern string</li> </ul> </li> </ul>","tags":["string"]},{"location":"problems/pattern-matching/#solutions","title":"Solutions","text":"","tags":["string"]},{"location":"problems/pattern-matching/#naive-approach","title":"Naive Approach","text":"","tags":["string"]},{"location":"problems/pattern-matching/#kmp-algorithm","title":"KMP Algorithm","text":"C++ <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvector&lt;int&gt; computeLPS(string pat) {\n  vector&lt;int&gt; lps(pat.length(), 0);\n  int len = 0;\n  int i = 1;\n  while (i &lt; pat.length()) {\n    if (pat[i] == pat[len]) {\n      len++;\n      lps[i] = len;\n      i++;\n    } else {\n      if (len != 0) {\n        len = lps[len - 1];\n      } else {\n        lps[i] = 0;\n        i++;\n      }\n    }\n  }\n  return lps;\n}\n\nvoid KMPSearch(string pat, string txt) {\n  vector&lt;int&gt; lps = computeLPS(pat);\n  int i = 0;\n  int j = 0;\n  while ((txt.length() - i) &gt;= (pat.length() - j)) {\n    if (pat[j] == txt[i]) {\n      j++;\n      i++;\n    }\n    if (j == pat.length()) {\n      printf(\"Found pattern at index %d \", i - j);\n      j = lps[j - 1];\n    } else if (i &lt; txt.length() &amp;&amp; pat[j] != txt[i]) {\n      if (j != 0)\n        j = lps[j - 1];\n      else\n        i = i + 1;\n    }\n  }\n}\n\nint main() {\n  string txt = \"ABABDABACDABABCABAB\";\n  string pat = \"ABABCABAB\";\n  KMPSearch(pat, txt);\n  return 0;\n}\n</code></pre>","tags":["string"]},{"location":"problems/super-egg-drop/","title":"Pattern Matching","text":"","tags":["dp"]},{"location":"problems/super-egg-drop/#problem","title":"Problem","text":"<p>https://leetcode.com/problems/super-egg-drop</p>","tags":["dp"]},{"location":"problems/super-egg-drop/#solutions","title":"Solutions","text":"","tags":["dp"]},{"location":"problems/super-egg-drop/#modified-dynamic-programming","title":"Modified Dynamic Programming","text":"<ul> <li>\u201cHow many moves do you need to check <code>N</code> floors if you have <code>K</code> eggs\u201d to:</li> <li> <p>\u201cHow many floors can you check given <code>M</code> moves available and <code>K</code> eggs\u201d.</p> </li> <li> <p>If you can solve this second problem than you can just increase the moves <code>M</code>   one by one until you are able to check a number of floors larger or equal to   the number <code>N</code> which the problem requires.</p> </li> <li>He then defined <code>dp[M][K]</code><ul> <li>as the maximum number of floors that you can check within <code>M</code> moves given <code>K</code> eggs</li> </ul> </li> <li>A move essentially is dropping an egg and it either breaks or doesn\u2019t break.<ul> <li>Case A: The egg breaks and now you have spent <code>1</code> move <code>(M=M-1)</code> and also lost <code>1</code> egg <code>(K=K-1)</code>. You can still check <code>dp[M-1][K-1]</code> floors, with your remaining eggs and moves.</li> <li>Case B: The egg remains and you only loose one move <code>(M=M-1)</code>. You can still check <code>dp[M-1][K]</code> floors.</li> </ul> </li> <li>Additionally you just checked a floor by dropping the egg from it.</li> <li>Therefore <code>dp[M][K] = dp[M - 1][k - 1] + dp[M - 1][K] + 1</code></li> <li> <p>As you can see we can easily calculate how many floors we can check in <code>M</code> moves   if we know how many floors we can check in <code>M-1</code> moves.</p> </li> <li> <p>However we not only have to know how many floors we can can check with one move less,   but also how many we can check with one move and one egg less.</p> </li> <li> <p>Therefore we have to calculate how many moves we can check for all number off eggs from <code>1</code> to <code>K</code>.</p> </li> <li> <p>An example:</p> </li> </ul> <p><code>N = 6</code> and <code>K = 2</code></p> <ul> <li> <p>Turn the problem around: How many floors can you check with 2 eggs and M moves:</p> </li> <li> <p>Solve for<code>M=1, K=1,2</code> you can only check 1 floor (since afterwards you have no more moves left)</p> </li> <li> <p>Solve for <code>M=2, K=1</code></p> <ul> <li>Case A: Your egg breaks, you have no more eggs left and can check nothing. <code>dp[M=1,K=0]=0</code></li> <li>Case B: your egg survives and you can use it to test an additional floor above the floor you just tested. dp[M=1,K=1]=1</li> <li><code>dp[2][1]=dp[1][0]+dp[1][1]+1=0+1+1=2</code></li> </ul> </li> <li> <p>Solve for <code>M=2, K=2</code></p> <ul> <li>Case A:<ul> <li>Your egg breaks: you have 1 move left and 1 egg.</li> <li>Since you know that the floor <code>F</code> where the eggs break is below the   floor you just tested you can now check <code>dp[M=1,K=1]</code> floors below you,   with only 1 move left you check 1 additional floor below.   <code>dp[M=1,K=1]=1</code></li> </ul> </li> <li>Case B:<ul> <li>Your eggs survives and you start to search above the current floor.</li> <li><code>dp[1][2]</code> is still only 1 move and we can check 1 floor. <code>dp[1][2]</code></li> </ul> </li> <li><code>dp[2][2]=1+1+1=3</code></li> </ul> </li> <li> <p>Solve for <code>M=3, K=1</code></p> <ul> <li>Case A:<ul> <li>Your egg breaks and you are out of eggs, no chance to check anything anymore</li> </ul> </li> <li>Case B:<ul> <li>Your egg survives and you can use it for 2 more moves <code>dp[2][1]</code>,   which as we established above is enough to check 2 floors.</li> </ul> </li> <li><code>dp[3][1]=0+2+1=3</code></li> </ul> </li> <li> <p>Solve for <code>M=3, K=2</code></p> <ul> <li>Case A: Your egg breaks and you check <code>dp[2][1]=2</code> additional floors</li> <li>Case B: Your egg survives and you check <code>dp[2][2]=3</code> additional floors</li> <li><code>dp[3][2]=2+3+1=6</code></li> </ul> </li> <li> <p>As you can see 3 moves and 2 eggs allows you to check 6 floors.</p> </li> <li>Which answers the original question how many moves you need to check 6 floors given 2 eggs,</li> </ul> <p>The answer is 3</p> <pre><code>class Solution {\npublic:\n    int superEggDrop(int k, int n) {\n        vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt; (k+1, 0));\n        int m  = 0; // no of moves\n        while(dp[m][k] &lt; n){ // run till you can't validate the nth floor\n            // for m moves now calaculate for eggs\n            m++;\n            for(int e=1;e&lt;=k;e++){\n                dp[m][e] = 1 + dp[m-1][e-1] + dp[m-1][e]; \n            }\n        }\n\n        return m;\n    }\n};\n</code></pre>","tags":["dp"]}]}